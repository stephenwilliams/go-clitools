// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package tools

import "fmt"
import "encoding/json"
import "reflect"

// UnmarshalJSON implements json.Unmarshaler.
func (j *OptionSet) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["options"]; !ok || v == nil {
		return fmt.Errorf("field options: required")
	}
	type Plain OptionSet
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = OptionSet(plain)
	return nil
}

type Argument struct {
	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty"`

	// ExcludeDefaultValue corresponds to the JSON schema field "excludeDefaultValue".
	ExcludeDefaultValue *bool `json:"excludeDefaultValue,omitempty"`

	// Format corresponds to the JSON schema field "format".
	Format *string `json:"format,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name"`

	// Type corresponds to the JSON schema field "type".
	Type ArgumentType `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Argument) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain Argument
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Argument(plain)
	return nil
}

type ArgumentSet struct {
	// Args corresponds to the JSON schema field "args".
	Args []Argument `json:"args"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty"`

	// ExportedNameSuffix corresponds to the JSON schema field "exportedNameSuffix".
	ExportedNameSuffix string `json:"exportedNameSuffix"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ArgumentSet) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["args"]; !ok || v == nil {
		return fmt.Errorf("field args: required")
	}
	if v, ok := raw["exportedNameSuffix"]; !ok || v == nil {
		return fmt.Errorf("field exportedNameSuffix: required")
	}
	type Plain ArgumentSet
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ArgumentSet(plain)
	return nil
}

type ArgumentType interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OptionSetRef) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain OptionSetRef
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = OptionSetRef(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VersionProvider) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["commandArgs"]; !ok || v == nil {
		return fmt.Errorf("field commandArgs: required")
	}
	if v, ok := raw["selector"]; !ok || v == nil {
		return fmt.Errorf("field selector: required")
	}
	type Plain VersionProvider
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["captureStderr"]; !ok || v == nil {
		plain.CaptureStderr = false
	}
	*j = VersionProvider(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VersionSelectorSplitString) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index: required")
	}
	type Plain VersionSelectorSplitString
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["separator"]; !ok || v == nil {
		plain.Separator = " "
	}
	*j = VersionSelectorSplitString(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Option) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["exportedName"]; !ok || v == nil {
		return fmt.Errorf("field exportedName: required")
	}
	if v, ok := raw["format"]; !ok || v == nil {
		return fmt.Errorf("field format: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain Option
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Option(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VersionSelectorSplitLine) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index: required")
	}
	type Plain VersionSelectorSplitLine
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VersionSelectorSplitLine(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Command) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["exportedName"]; !ok || v == nil {
		return fmt.Errorf("field exportedName: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain Command
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Command(plain)
	return nil
}

type CommandGroup struct {
	// Commands corresponds to the JSON schema field "commands".
	Commands []Command `json:"commands"`

	// Description corresponds to the JSON schema field "description".
	Description string `json:"description"`

	// Groups corresponds to the JSON schema field "groups".
	Groups []CommandGroup `json:"groups,omitempty"`

	// Package corresponds to the JSON schema field "package".
	Package string `json:"package"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommandGroup) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["commands"]; !ok || v == nil {
		return fmt.Errorf("field commands: required")
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description: required")
	}
	if v, ok := raw["package"]; !ok || v == nil {
		return fmt.Errorf("field package: required")
	}
	type Plain CommandGroup
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CommandGroup(plain)
	return nil
}

type GithubReleaseDownloader struct {
	// ArchivePath corresponds to the JSON schema field "archivePath".
	ArchivePath *string `json:"archivePath,omitempty"`

	// Archived corresponds to the JSON schema field "archived".
	Archived *bool `json:"archived,omitempty"`

	// AssetSelector corresponds to the JSON schema field "assetSelector".
	AssetSelector string `json:"assetSelector"`

	// AssetSelectorRegexp corresponds to the JSON schema field "assetSelectorRegexp".
	AssetSelectorRegexp *bool `json:"assetSelectorRegexp,omitempty"`

	// When multiple different "releases" are released from a singular GitHub
	// repository
	MultipleReleases *bool `json:"multipleReleases,omitempty"`

	// When multiple different "releases" are released from a singular GitHub
	// repository.
	MultipleReleasesTagPrefix *string `json:"multipleReleasesTagPrefix,omitempty"`

	// GitHub repository owner
	Owner string `json:"owner"`

	// GitHub repository name
	Repository string `json:"repository"`

	// TagPrefix corresponds to the JSON schema field "tagPrefix".
	TagPrefix *string `json:"tagPrefix,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GithubReleaseDownloader) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["assetSelector"]; !ok || v == nil {
		return fmt.Errorf("field assetSelector: required")
	}
	if v, ok := raw["owner"]; !ok || v == nil {
		return fmt.Errorf("field owner: required")
	}
	if v, ok := raw["repository"]; !ok || v == nil {
		return fmt.Errorf("field repository: required")
	}
	type Plain GithubReleaseDownloader
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GithubReleaseDownloader(plain)
	return nil
}

type Downloaders struct {
	// GithubRelease corresponds to the JSON schema field "githubRelease".
	GithubRelease *GithubReleaseDownloader `json:"githubRelease,omitempty"`
}

type GoType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolProviderDownloader) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["downloader"]; !ok || v == nil {
		return fmt.Errorf("field downloader: required")
	}
	type Plain ToolProviderDownloader
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ToolProviderDownloader(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GoType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GoType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GoType, v)
	}
	*j = GoType(v)
	return nil
}

const GoTypeBoolean GoType = "boolean"
const GoTypeDuration GoType = "duration"

type Command struct {
	// ArgsFirst corresponds to the JSON schema field "argsFirst".
	ArgsFirst *bool `json:"argsFirst,omitempty"`

	// ArgumentSets corresponds to the JSON schema field "argumentSets".
	ArgumentSets []ArgumentSet `json:"argumentSets,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty"`

	// ExportedName corresponds to the JSON schema field "exportedName".
	ExportedName string `json:"exportedName"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name"`

	// OptionSets corresponds to the JSON schema field "optionSets".
	OptionSets []OptionSetRef `json:"optionSets,omitempty"`

	// Options corresponds to the JSON schema field "options".
	Options []Option `json:"options,omitempty"`

	// Package corresponds to the JSON schema field "package".
	Package *string `json:"package,omitempty"`

	// SubCommandPath corresponds to the JSON schema field "subCommandPath".
	SubCommandPath []string `json:"subCommandPath,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolProviderDefinedToolPath) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path: required")
	}
	type Plain ToolProviderDefinedToolPath
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ToolProviderDefinedToolPath(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StringReplacer) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["new"]; !ok || v == nil {
		return fmt.Errorf("field new: required")
	}
	if v, ok := raw["old"]; !ok || v == nil {
		return fmt.Errorf("field old: required")
	}
	type Plain StringReplacer
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StringReplacer(plain)
	return nil
}

const GoTypeInt GoType = "int"
const GoTypeString GoType = "string"
const GoTypeStringSlice GoType = "stringSlice"

type Option struct {
	// Only valid for slice types. Appends the values to the args array.
	Append *bool `json:"append,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty"`

	// ExportedName corresponds to the JSON schema field "exportedName".
	ExportedName string `json:"exportedName"`

	// Format corresponds to the JSON schema field "format".
	Format []string `json:"format"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name"`

	// NoValue corresponds to the JSON schema field "noValue".
	NoValue *bool `json:"noValue,omitempty"`

	// Only valid for slice types. Whether or not the format is repeated for each
	// value of the slice.
	Repeated *bool `json:"repeated,omitempty"`

	// Required corresponds to the JSON schema field "required".
	Required *bool `json:"required,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type OptionType `json:"type"`

	// When using type '[]string' and this is set, it changes the value injected to be
	// string joined on this character
	ValueJoin *string `json:"valueJoin,omitempty"`
}

type OptionSet struct {
	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name"`

	// Options corresponds to the JSON schema field "options".
	Options []Option `json:"options"`
}

type OptionSetRef struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name"`
}

type OptionType interface{}

type StringReplacer struct {
	// New corresponds to the JSON schema field "new".
	New string `json:"new"`

	// NumberOfReplacements corresponds to the JSON schema field
	// "numberOfReplacements".
	NumberOfReplacements *int `json:"numberOfReplacements,omitempty"`

	// Old corresponds to the JSON schema field "old".
	Old string `json:"old"`
}

type Tool struct {
	// Schema corresponds to the JSON schema field "$schema".
	Schema *string `json:"$schema,omitempty"`

	// DefaultToolProvider corresponds to the JSON schema field "defaultToolProvider".
	DefaultToolProvider *ToolProvider `json:"defaultToolProvider,omitempty"`

	// Description of the CLI tool
	Description string `json:"description"`

	// Downloaders corresponds to the JSON schema field "downloaders".
	Downloaders *Downloaders `json:"downloaders,omitempty"`

	// Name of the executable
	ExecutableName string `json:"executableName"`

	// The exported name of the tool. Used for naming the tool info
	ExportedName string `json:"exportedName"`

	// Groups corresponds to the JSON schema field "groups".
	Groups []CommandGroup `json:"groups"`

	// Name of the CLI tool
	Name string `json:"name"`

	// OptionSets corresponds to the JSON schema field "optionSets".
	OptionSets []OptionSet `json:"optionSets,omitempty"`

	// Package corresponds to the JSON schema field "package".
	Package string `json:"package"`

	// VersionProvider corresponds to the JSON schema field "versionProvider".
	VersionProvider VersionProvider `json:"versionProvider"`
}

type ToolProvider struct {
	// Chain corresponds to the JSON schema field "chain".
	Chain *ToolProviderChain `json:"chain,omitempty"`

	// DefinedToolPath corresponds to the JSON schema field "definedToolPath".
	DefinedToolPath *ToolProviderDefinedToolPath `json:"definedToolPath,omitempty"`

	// Downloader corresponds to the JSON schema field "downloader".
	Downloader *ToolProviderDownloader `json:"downloader,omitempty"`

	// Path corresponds to the JSON schema field "path".
	Path *bool `json:"path,omitempty"`
}

type ToolProviderChain struct {
	// Providers corresponds to the JSON schema field "providers".
	Providers []*ToolProvider `json:"providers,omitempty"`
}

type ToolProviderDefinedToolPath struct {
	// Path corresponds to the JSON schema field "path".
	Path string `json:"path"`
}

type ToolProviderDownloader struct {
	// Downloader corresponds to the JSON schema field "downloader".
	Downloader string `json:"downloader"`
}

type VersionProvider struct {
	// CaptureStderr corresponds to the JSON schema field "captureStderr".
	CaptureStderr bool `json:"captureStderr,omitempty"`

	// CommandArgs corresponds to the JSON schema field "commandArgs".
	CommandArgs []string `json:"commandArgs"`

	// Selector corresponds to the JSON schema field "selector".
	Selector VersionSelector `json:"selector"`
}

type VersionSelector struct {
	// EqualsReplace corresponds to the JSON schema field "equalsReplace".
	EqualsReplace *StringReplacer `json:"equalsReplace,omitempty"`

	// SplitLine corresponds to the JSON schema field "splitLine".
	SplitLine *VersionSelectorSplitLine `json:"splitLine,omitempty"`

	// SplitString corresponds to the JSON schema field "splitString".
	SplitString *VersionSelectorSplitString `json:"splitString,omitempty"`

	// StringReplace corresponds to the JSON schema field "stringReplace".
	StringReplace []StringReplacer `json:"stringReplace,omitempty"`

	// TrimPrefix corresponds to the JSON schema field "trimPrefix".
	TrimPrefix *string `json:"trimPrefix,omitempty"`

	// TrimSuffix corresponds to the JSON schema field "trimSuffix".
	TrimSuffix *string `json:"trimSuffix,omitempty"`
}

type VersionSelectorSplitLine struct {
	// Index corresponds to the JSON schema field "index".
	Index int `json:"index"`
}

type VersionSelectorSplitString struct {
	// Index corresponds to the JSON schema field "index".
	Index int `json:"index"`

	// Separator corresponds to the JSON schema field "separator".
	Separator string `json:"separator,omitempty"`
}

var enumValues_GoType = []interface{}{
	"boolean",
	"duration",
	"int",
	"string",
	"stringSlice",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tool) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description: required")
	}
	if v, ok := raw["executableName"]; !ok || v == nil {
		return fmt.Errorf("field executableName: required")
	}
	if v, ok := raw["exportedName"]; !ok || v == nil {
		return fmt.Errorf("field exportedName: required")
	}
	if v, ok := raw["groups"]; !ok || v == nil {
		return fmt.Errorf("field groups: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["package"]; !ok || v == nil {
		return fmt.Errorf("field package: required")
	}
	if v, ok := raw["versionProvider"]; !ok || v == nil {
		return fmt.Errorf("field versionProvider: required")
	}
	type Plain Tool
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Tool(plain)
	return nil
}
