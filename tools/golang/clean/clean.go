// Generated by toolgen. DO NOT EDIT.
// Generated from tool specification:
//   _build/specifications/go.json

package clean

import (
	"github.com/stephenwilliams/go-clitools/internal/defaults"
	"github.com/stephenwilliams/go-clitools/ptrhelpers"
	"github.com/stephenwilliams/go-clitools/tools"
	"github.com/stephenwilliams/go-clitools/tools/golang"
)

// Clean removes object files from package source directories.
// The go command builds most objects in a temporary directory,
// so go clean is mainly concerned with object files left by other
// tools or by manual invocations of go build.
//
// If a package argument is given or the -i or -r flag is set,
// clean removes the following files from each of the
// source directories corresponding to the import paths:
//
// 	_obj/            old object directory, left from Makefiles
// 	_test/           old test directory, left from Makefiles
// 	_testmain.go     old gotest file, left from Makefiles
// 	test.out         old test log, left from Makefiles
// 	build.out        old test log, left from Makefiles
// 	*.[568ao]        object files, left from Makefiles
//
// 	DIR(.exe)        from go build
// 	DIR.test(.exe)   from go test -c
// 	MAINFILE(.exe)   from go build MAINFILE.go
// 	*.so             from SWIG
//
// In the list, DIR represents the final path element of the
// directory, and MAINFILE is the base name of any Go source
// file in the directory that is not included when building
// the package.
func Clean(opts ...CleanOpt) *tools.CommandContext {
	options := &cleanOptions{}

	for _, optFunc := range opts {
		optFunc(options)
	}

	var _args []string
	_args = append(_args, "clean")

	_args = append(_args, options.toArgs()...)

	return &tools.CommandContext{
		Args: _args,
		Path: tools.MustResolveTool(golang.GoToolInfo, defaults.String(options.ToolVersion, golang.DefaultToolVersion), options.ToolProvider, golang.DefaultToolProvider, tools.DefaultToolProvider),
	}
}

// Clean removes object files from package source directories.
// The go command builds most objects in a temporary directory,
// so go clean is mainly concerned with object files left by other
// tools or by manual invocations of go build.
//
// If a package argument is given or the -i or -r flag is set,
// clean removes the following files from each of the
// source directories corresponding to the import paths:
//
// 	_obj/            old object directory, left from Makefiles
// 	_test/           old test directory, left from Makefiles
// 	_testmain.go     old gotest file, left from Makefiles
// 	test.out         old test log, left from Makefiles
// 	build.out        old test log, left from Makefiles
// 	*.[568ao]        object files, left from Makefiles
//
// 	DIR(.exe)        from go build
// 	DIR.test(.exe)   from go test -c
// 	MAINFILE(.exe)   from go build MAINFILE.go
// 	*.so             from SWIG
//
// In the list, DIR represents the final path element of the
// directory, and MAINFILE is the base name of any Go source
// file in the directory that is not included when building
// the package.
func CleanWithPackages(packages []string, opts ...CleanOpt) *tools.CommandContext {
	options := &cleanOptions{}

	for _, optFunc := range opts {
		optFunc(options)
	}

	var _args []string
	_args = append(_args, "clean")

	_args = append(_args, options.toArgs()...)
	_args = append(_args, packages...)

	return &tools.CommandContext{
		Args: _args,
		Path: tools.MustResolveTool(golang.GoToolInfo, defaults.String(options.ToolVersion, golang.DefaultToolVersion), options.ToolProvider, golang.DefaultToolProvider, tools.DefaultToolProvider),
	}
}

type CleanOpt func(*cleanOptions)

func SetToolProvider(p tools.ToolProvider) CleanOpt {
	return func(opts *cleanOptions) {
		opts.ToolProvider = p
	}
}

func SetToolVersion(v string) CleanOpt {
	return func(opts *cleanOptions) {
		opts.ToolVersion = v
	}
}

// causes clean to remove the corresponding installed
// archive or binary (what 'go install' would create).
func Installed() CleanOpt {
	return func(opts *cleanOptions) {
		opts.installed = ptrhelpers.Bool(true)
	}
}

// causes clean to be applied recursively to all the
// dependencies of the packages named by the import paths.
func Recursive() CleanOpt {
	return func(opts *cleanOptions) {
		opts.recursive = ptrhelpers.Bool(true)
	}
}

// flag causes clean to remove the entire go build cache.
func Cache() CleanOpt {
	return func(opts *cleanOptions) {
		opts.cache = ptrhelpers.Bool(true)
	}
}

// flag causes clean to expire all test results in the
// go build cache.
func TestCache() CleanOpt {
	return func(opts *cleanOptions) {
		opts.testcache = ptrhelpers.Bool(true)
	}
}

// causes clean to remove the entire module
// download cache, including unpacked source code of versioned
// dependencies.
func ModCache() CleanOpt {
	return func(opts *cleanOptions) {
		opts.modcache = ptrhelpers.Bool(true)
	}
}

// print the commands but do not run them.
func PrintCommandsOnly() CleanOpt {
	return func(opts *cleanOptions) {
		opts.printCommandsOnly = ptrhelpers.Bool(true)
	}
}

// print the commands.
func PrintCommands() CleanOpt {
	return func(opts *cleanOptions) {
		opts.printCommands = ptrhelpers.Bool(true)
	}
}

type cleanOptions struct {
	ToolProvider      tools.ToolProvider
	ToolVersion       string
	installed         *bool
	recursive         *bool
	cache             *bool
	testcache         *bool
	modcache          *bool
	printCommandsOnly *bool
	printCommands     *bool
}

func (o *cleanOptions) toArgs() []string {
	var renderedArgs []string

	if o.installed != nil {
		renderedArgs = append(renderedArgs, "-i")
	}

	if o.recursive != nil {
		renderedArgs = append(renderedArgs, "-r")
	}

	if o.cache != nil {
		renderedArgs = append(renderedArgs, "-cache")
	}

	if o.testcache != nil {
		renderedArgs = append(renderedArgs, "-testcache")
	}

	if o.modcache != nil {
		renderedArgs = append(renderedArgs, "-modcache")
	}

	if o.printCommandsOnly != nil {
		renderedArgs = append(renderedArgs, "-n")
	}

	if o.printCommands != nil {
		renderedArgs = append(renderedArgs, "-x")
	}

	return renderedArgs
}
