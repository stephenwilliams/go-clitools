// Generated by toolgen. DO NOT EDIT.
// Generated from tool specification:
//   _build/specifications/go.json

package get

import (
	"fmt"
	"strings"

	"github.com/stephenwilliams/go-clitools/internal/defaults"
	"github.com/stephenwilliams/go-clitools/ptrhelpers"
	"github.com/stephenwilliams/go-clitools/tools"
	"github.com/stephenwilliams/go-clitools/tools/golang"
)

// Get resolves and adds dependencies to the current development module
// and then builds and installs them.
//
// The first step is to resolve which dependencies to add.
//
// For each named package or package pattern, get must decide which version of
// the corresponding module to use. By default, get looks up the latest tagged
// release version, such as v0.4.5 or v1.2.3. If there are no tagged release
// versions, get looks up the latest tagged pre-release version, such as
// v0.0.1-pre1. If there are no tagged versions at all, get looks up the latest
// known commit. If the module is not already required at a later version
// (for example, a pre-release newer than the latest release), get will use
// the version it looked up. Otherwise, get will use the currently
// required version.
//
// This default version selection can be overridden by adding an @version
// suffix to the package argument, as in 'go get golang.org/x/text@v0.3.0'.
// The version may be a prefix: @v1 denotes the latest available version starting
// with v1. See 'go help modules' under the heading 'Module queries' for the
// full query syntax.
//
// For modules stored in source control repositories, the version suffix can
// also be a commit hash, branch identifier, or other syntax known to the
// source control system, as in 'go get golang.org/x/text@master'. Note that
// branches with names that overlap with other module query syntax cannot be
// selected explicitly. For example, the suffix @v2 means the latest version
// starting with v2, not the branch named v2.
//
// If a module under consideration is already a dependency of the current
// development module, then get will update the required version.
// Specifying a version earlier than the current required version is valid and
// downgrades the dependency. The version suffix @none indicates that the
// dependency should be removed entirely, downgrading or removing modules
// depending on it as needed.
//
// The version suffix @latest explicitly requests the latest minor release of the
// module named by the given path. The suffix @upgrade is like @latest but
// will not downgrade a module if it is already required at a revision or
// pre-release version newer than the latest released version. The suffix
// @patch requests the latest patch release: the latest released version
// with the same major and minor version numbers as the currently required
// version. Like @upgrade, @patch will not downgrade a module already required
// at a newer version. If the path is not already required, @upgrade and @patch
// are equivalent to @latest.
//
// Although get defaults to using the latest version of the module containing
// a named package, it does not use the latest version of that module's
// dependencies. Instead it prefers to use the specific dependency versions
// requested by that module. For example, if the latest A requires module
// B v1.2.3, while B v1.2.4 and v1.3.1 are also available, then 'go get A'
// will use the latest A but then use B v1.2.3, as requested by A. (If there
// are competing requirements for a particular module, then 'go get' resolves
// those requirements by taking the maximum requested version.)
func Get(opts ...GetOpt) *tools.CommandContext {
	options := &getOptions{}

	for _, optFunc := range opts {
		optFunc(options)
	}

	var _args []string
	_args = append(_args, "get")

	_args = append(_args, options.toArgs()...)

	return &tools.CommandContext{
		Args: _args,
		Path: tools.MustResolveTool(golang.GoToolInfo, defaults.String(options.ToolVersion, golang.DefaultToolVersion), options.ToolProvider, golang.DefaultToolProvider, tools.DefaultToolProvider),
	}
}

// Get resolves and adds dependencies to the current development module
// and then builds and installs them.
//
// The first step is to resolve which dependencies to add.
//
// For each named package or package pattern, get must decide which version of
// the corresponding module to use. By default, get looks up the latest tagged
// release version, such as v0.4.5 or v1.2.3. If there are no tagged release
// versions, get looks up the latest tagged pre-release version, such as
// v0.0.1-pre1. If there are no tagged versions at all, get looks up the latest
// known commit. If the module is not already required at a later version
// (for example, a pre-release newer than the latest release), get will use
// the version it looked up. Otherwise, get will use the currently
// required version.
//
// This default version selection can be overridden by adding an @version
// suffix to the package argument, as in 'go get golang.org/x/text@v0.3.0'.
// The version may be a prefix: @v1 denotes the latest available version starting
// with v1. See 'go help modules' under the heading 'Module queries' for the
// full query syntax.
//
// For modules stored in source control repositories, the version suffix can
// also be a commit hash, branch identifier, or other syntax known to the
// source control system, as in 'go get golang.org/x/text@master'. Note that
// branches with names that overlap with other module query syntax cannot be
// selected explicitly. For example, the suffix @v2 means the latest version
// starting with v2, not the branch named v2.
//
// If a module under consideration is already a dependency of the current
// development module, then get will update the required version.
// Specifying a version earlier than the current required version is valid and
// downgrades the dependency. The version suffix @none indicates that the
// dependency should be removed entirely, downgrading or removing modules
// depending on it as needed.
//
// The version suffix @latest explicitly requests the latest minor release of the
// module named by the given path. The suffix @upgrade is like @latest but
// will not downgrade a module if it is already required at a revision or
// pre-release version newer than the latest released version. The suffix
// @patch requests the latest patch release: the latest released version
// with the same major and minor version numbers as the currently required
// version. Like @upgrade, @patch will not downgrade a module already required
// at a newer version. If the path is not already required, @upgrade and @patch
// are equivalent to @latest.
//
// Although get defaults to using the latest version of the module containing
// a named package, it does not use the latest version of that module's
// dependencies. Instead it prefers to use the specific dependency versions
// requested by that module. For example, if the latest A requires module
// B v1.2.3, while B v1.2.4 and v1.3.1 are also available, then 'go get A'
// will use the latest A but then use B v1.2.3, as requested by A. (If there
// are competing requirements for a particular module, then 'go get' resolves
// those requirements by taking the maximum requested version.)
func GetWithPackage(pkg string, opts ...GetOpt) *tools.CommandContext {
	options := &getOptions{}

	for _, optFunc := range opts {
		optFunc(options)
	}

	var _args []string
	_args = append(_args, "get")

	_args = append(_args, options.toArgs()...)
	_args = append(_args, pkg)

	return &tools.CommandContext{
		Args: _args,
		Path: tools.MustResolveTool(golang.GoToolInfo, defaults.String(options.ToolVersion, golang.DefaultToolVersion), options.ToolProvider, golang.DefaultToolProvider, tools.DefaultToolProvider),
	}
}

// Get resolves and adds dependencies to the current development module
// and then builds and installs them.
//
// The first step is to resolve which dependencies to add.
//
// For each named package or package pattern, get must decide which version of
// the corresponding module to use. By default, get looks up the latest tagged
// release version, such as v0.4.5 or v1.2.3. If there are no tagged release
// versions, get looks up the latest tagged pre-release version, such as
// v0.0.1-pre1. If there are no tagged versions at all, get looks up the latest
// known commit. If the module is not already required at a later version
// (for example, a pre-release newer than the latest release), get will use
// the version it looked up. Otherwise, get will use the currently
// required version.
//
// This default version selection can be overridden by adding an @version
// suffix to the package argument, as in 'go get golang.org/x/text@v0.3.0'.
// The version may be a prefix: @v1 denotes the latest available version starting
// with v1. See 'go help modules' under the heading 'Module queries' for the
// full query syntax.
//
// For modules stored in source control repositories, the version suffix can
// also be a commit hash, branch identifier, or other syntax known to the
// source control system, as in 'go get golang.org/x/text@master'. Note that
// branches with names that overlap with other module query syntax cannot be
// selected explicitly. For example, the suffix @v2 means the latest version
// starting with v2, not the branch named v2.
//
// If a module under consideration is already a dependency of the current
// development module, then get will update the required version.
// Specifying a version earlier than the current required version is valid and
// downgrades the dependency. The version suffix @none indicates that the
// dependency should be removed entirely, downgrading or removing modules
// depending on it as needed.
//
// The version suffix @latest explicitly requests the latest minor release of the
// module named by the given path. The suffix @upgrade is like @latest but
// will not downgrade a module if it is already required at a revision or
// pre-release version newer than the latest released version. The suffix
// @patch requests the latest patch release: the latest released version
// with the same major and minor version numbers as the currently required
// version. Like @upgrade, @patch will not downgrade a module already required
// at a newer version. If the path is not already required, @upgrade and @patch
// are equivalent to @latest.
//
// Although get defaults to using the latest version of the module containing
// a named package, it does not use the latest version of that module's
// dependencies. Instead it prefers to use the specific dependency versions
// requested by that module. For example, if the latest A requires module
// B v1.2.3, while B v1.2.4 and v1.3.1 are also available, then 'go get A'
// will use the latest A but then use B v1.2.3, as requested by A. (If there
// are competing requirements for a particular module, then 'go get' resolves
// those requirements by taking the maximum requested version.)
func GetWithPackages(pkgs []string, opts ...GetOpt) *tools.CommandContext {
	options := &getOptions{}

	for _, optFunc := range opts {
		optFunc(options)
	}

	var _args []string
	_args = append(_args, "get")

	_args = append(_args, options.toArgs()...)
	_args = append(_args, pkgs...)

	return &tools.CommandContext{
		Args: _args,
		Path: tools.MustResolveTool(golang.GoToolInfo, defaults.String(options.ToolVersion, golang.DefaultToolVersion), options.ToolProvider, golang.DefaultToolProvider, tools.DefaultToolProvider),
	}
}

type GetOpt func(*getOptions)

func SetToolProvider(p tools.ToolProvider) GetOpt {
	return func(opts *getOptions) {
		opts.ToolProvider = p
	}
}

func SetToolVersion(v string) GetOpt {
	return func(opts *getOptions) {
		opts.ToolVersion = v
	}
}

// instructs get to consider modules needed to build tests of
// packages specified on the command line.
func Test() GetOpt {
	return func(opts *getOptions) {
		opts.test = ptrhelpers.Bool(true)
	}
}

// instructs get to update modules providing dependencies
// of packages named on the command line to use newer minor or patch
// releases when available. Continuing the previous example, 'go get -u A'
// will use the latest A with B v1.3.1 (not B v1.2.3). If B requires module C,
// but C does not provide any packages needed to build packages in A
// (not including tests), then C will not be updated.
func Update() GetOpt {
	return func(opts *getOptions) {
		opts.update = ptrhelpers.Bool(true)
	}
}

// instructs get to update dependencies,
// but changes the default to select patch releases.
// Continuing the previous example,
// 'go get -u=patch A@latest' will use the latest A with B v1.2.4 (not B v1.2.3),
// while 'go get -u=patch A' will use a patch release of A instead.
func UpdatePatch() GetOpt {
	return func(opts *getOptions) {
		opts.updatePatch = ptrhelpers.Bool(true)
	}
}

// permits fetching from repositories and resolving
// custom domains using insecure schemes such as HTTP. Use with caution. The
// GOINSECURE environment variable is usually a better alternative, since it
// provides control over which modules may be retrieved using an insecure scheme.
// See 'go help environment' for details.
func Insecure() GetOpt {
	return func(opts *getOptions) {
		opts.insecure = ptrhelpers.Bool(true)
	}
}

// instructs get to download the source code needed to build
// the named packages, including downloading necessary dependencies,
// but not to build and install them.
func Download() GetOpt {
	return func(opts *getOptions) {
		opts.download = ptrhelpers.Bool(true)
	}
}

// force rebuilding of packages that are already up-to-date.
func ForceRebuild() GetOpt {
	return func(opts *getOptions) {
		opts.forceRebuild = ptrhelpers.Bool(true)
	}
}

// the number of programs, such as build commands or
// test binaries, that can be run in parallel.
// The default is the number of CPUs available.
func Workers(value int) GetOpt {
	return func(opts *getOptions) {
		opts.workers = &value
	}
}

// enable data race detection.
// Supported only on linux/amd64, freebsd/amd64, darwin/amd64, windows/amd64,
// linux/ppc64le and linux/arm64 (only for 48-bit VMA).
func Race() GetOpt {
	return func(opts *getOptions) {
		opts.race = ptrhelpers.Bool(true)
	}
}

// enable interoperation with memory sanitizer.
// Supported only on linux/amd64, linux/arm64
// and only with Clang/LLVM as the host C compiler.
// On linux/arm64, pie build mode will be used.
func EnableMemorySanitizer() GetOpt {
	return func(opts *getOptions) {
		opts.msan = ptrhelpers.Bool(true)
	}
}

// print the names of packages as they are compiled.
func Verbose() GetOpt {
	return func(opts *getOptions) {
		opts.verbose = ptrhelpers.Bool(true)
	}
}

// print the name of the temporary work directory and
// do not delete it when exiting.
func Work() GetOpt {
	return func(opts *getOptions) {
		opts.work = ptrhelpers.Bool(true)
	}
}

// value '[pattern=]arg list'
// arguments to pass on each go tool asm invocation.
func ASMFlags(value string) GetOpt {
	return func(opts *getOptions) {
		opts.asmflags = &value
	}
}

// build mode to use. See 'go help buildmode' for more.
func BuildMode(value string) GetOpt {
	return func(opts *getOptions) {
		opts.buildmode = &value
	}
}

// name of compiler to use, as in runtime.Compiler (gccgo or gc).
func Compiler(value string) GetOpt {
	return func(opts *getOptions) {
		opts.compiler = &value
	}
}

// value '[pattern=]arg list'
// arguments to pass on each gccgo compiler/linker invocation.
func GCCGoFlags(value string) GetOpt {
	return func(opts *getOptions) {
		opts.gccgoflags = &value
	}
}

// value '[pattern=]arg list'
// arguments to pass on each go tool compile invocation.
func GCCFlags(value string) GetOpt {
	return func(opts *getOptions) {
		opts.gccflags = &value
	}
}

// a suffix to use in the name of the package installation directory,
// in order to keep output separate from default builds.
// If using the -race flag, the install suffix is automatically set to race
// or, if set explicitly, has _race appended to it. Likewise for the -msan
// flag. Using a -buildmode option that requires non-default compile flags
// has a similar effect.
func InstallSuffix(value string) GetOpt {
	return func(opts *getOptions) {
		opts.installSuffix = &value
	}
}

// value '[pattern=]arg list'
// arguments to pass on each go tool link invocation.
func LDFlags(value string) GetOpt {
	return func(opts *getOptions) {
		opts.ldflags = &value
	}
}

// build code that will be linked against shared libraries previously
// created with -buildmode=shared.
func LinkShared() GetOpt {
	return func(opts *getOptions) {
		opts.linkShared = ptrhelpers.Bool(true)
	}
}

// module download mode to use: readonly, vendor, or mod.
// See 'go help modules' for more.
func Mod(value string) GetOpt {
	return func(opts *getOptions) {
		opts.mod = &value
	}
}

// leave newly-created directories in the module cache read-write
// instead of making them read-only.
func ModCacheRW() GetOpt {
	return func(opts *getOptions) {
		opts.modcacherw = ptrhelpers.Bool(true)
	}
}

// in module aware mode, read (and possibly write) an alternate go.mod
// file instead of the one in the module root directory. A file named
// "go.mod" must still be present in order to determine the module root
// directory, but it is not accessed. When -modfile is specified, an
// alternate go.sum file is also used: its path is derived from the
// -modfile flag by trimming the ".mod" extension and appending ".sum".
func ModFile(value string) GetOpt {
	return func(opts *getOptions) {
		opts.modfile = &value
	}
}

// install and load all packages from dir instead of the usual locations.
// For example, when building with a non-standard configuration,
// use -pkgdir to keep generated packages in a separate location
func PackageDir(value string) GetOpt {
	return func(opts *getOptions) {
		opts.pkgdir = &value
	}
}

// a comma-separated list of build tags to consider satisfied during the
// build. For more information about build tags, see the description of
// build constraints in the documentation for the go/build package.
// (Earlier versions of Go used a space-separated list, and that form
// is deprecated but still recognized.)
// NOTE: comma separation is handled automatically
func Tags(value ...string) GetOpt {
	return func(opts *getOptions) {
		opts.tags = value
	}
}

// remove all file system paths from the resulting executable.
// Instead of absolute file system paths, the recorded file names
// will begin with either "go" (for the standard library),
// or a module path@version (when using modules),
// or a plain import path (when using GOPATH).
func TrimPath() GetOpt {
	return func(opts *getOptions) {
		opts.trimpath = ptrhelpers.Bool(true)
	}
}

// a program to use to invoke toolchain programs like vet and asm.
// For example, instead of running asm, the go command will run
// 'cmd args /path/to/asm <arguments for asm>'.
func ToolExec(value string) GetOpt {
	return func(opts *getOptions) {
		opts.toolexec = &value
	}
}

type getOptions struct {
	ToolProvider  tools.ToolProvider
	ToolVersion   string
	test          *bool
	update        *bool
	updatePatch   *bool
	insecure      *bool
	download      *bool
	forceRebuild  *bool
	workers       *int
	race          *bool
	msan          *bool
	verbose       *bool
	work          *bool
	asmflags      *string
	buildmode     *string
	compiler      *string
	gccgoflags    *string
	gccflags      *string
	installSuffix *string
	ldflags       *string
	linkShared    *bool
	mod           *string
	modcacherw    *bool
	modfile       *string
	pkgdir        *string
	tags          []string
	trimpath      *bool
	toolexec      *string
}

func (o *getOptions) toArgs() []string {
	var renderedArgs []string

	if o.test != nil {
		renderedArgs = append(renderedArgs, "-t")
	}

	if o.update != nil {
		renderedArgs = append(renderedArgs, "-u")
	}

	if o.updatePatch != nil {
		renderedArgs = append(renderedArgs, "-u=patch")
	}

	if o.insecure != nil {
		renderedArgs = append(renderedArgs, "-insecure")
	}

	if o.download != nil {
		renderedArgs = append(renderedArgs, "-d")
	}

	if o.forceRebuild != nil {
		renderedArgs = append(renderedArgs, "-a")
	}

	if o.workers != nil {
		renderedArgs = append(renderedArgs, "-p", fmt.Sprintf("%d", ptrhelpers.IntValue(o.workers)))
	}

	if o.race != nil {
		renderedArgs = append(renderedArgs, "-race")
	}

	if o.msan != nil {
		renderedArgs = append(renderedArgs, "-msan")
	}

	if o.verbose != nil {
		renderedArgs = append(renderedArgs, "-v")
	}

	if o.work != nil {
		renderedArgs = append(renderedArgs, "-work")
	}

	if o.asmflags != nil {
		renderedArgs = append(renderedArgs, "-asmflags", fmt.Sprintf("%s", ptrhelpers.StringValue(o.asmflags)))
	}

	if o.buildmode != nil {
		renderedArgs = append(renderedArgs, "-buildmode", fmt.Sprintf("%s", ptrhelpers.StringValue(o.buildmode)))
	}

	if o.compiler != nil {
		renderedArgs = append(renderedArgs, "-compiler", fmt.Sprintf("%s", ptrhelpers.StringValue(o.compiler)))
	}

	if o.gccgoflags != nil {
		renderedArgs = append(renderedArgs, "-gccgoflags", fmt.Sprintf("%s", ptrhelpers.StringValue(o.gccgoflags)))
	}

	if o.gccflags != nil {
		renderedArgs = append(renderedArgs, "-gccflags", fmt.Sprintf("%s", ptrhelpers.StringValue(o.gccflags)))
	}

	if o.installSuffix != nil {
		renderedArgs = append(renderedArgs, "-installsuffix", fmt.Sprintf("%s", ptrhelpers.StringValue(o.installSuffix)))
	}

	if o.ldflags != nil {
		renderedArgs = append(renderedArgs, "-ldflags", fmt.Sprintf("%s", ptrhelpers.StringValue(o.ldflags)))
	}

	if o.linkShared != nil {
		renderedArgs = append(renderedArgs, "-linkshared")
	}

	if o.mod != nil {
		renderedArgs = append(renderedArgs, "-mod", fmt.Sprintf("%s", ptrhelpers.StringValue(o.mod)))
	}

	if o.modcacherw != nil {
		renderedArgs = append(renderedArgs, "-modcacherw")
	}

	if o.modfile != nil {
		renderedArgs = append(renderedArgs, "-modfile", fmt.Sprintf("%s", ptrhelpers.StringValue(o.modfile)))
	}

	if o.pkgdir != nil {
		renderedArgs = append(renderedArgs, "-pkgdir", fmt.Sprintf("%s", ptrhelpers.StringValue(o.pkgdir)))
	}

	if o.tags != nil {
		renderedArgs = append(renderedArgs, "-tags", fmt.Sprintf("%s", strings.Join(o.tags, ",")))
	}

	if o.trimpath != nil {
		renderedArgs = append(renderedArgs, "-trimpath")
	}

	if o.toolexec != nil {
		renderedArgs = append(renderedArgs, "-toolexec", fmt.Sprintf("%s", ptrhelpers.StringValue(o.toolexec)))
	}

	return renderedArgs
}
