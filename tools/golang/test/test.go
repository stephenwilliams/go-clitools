// Generated by toolgen. DO NOT EDIT.
// Generated from tool specification:
//   _build/specifications/go.json

package test

import (
	"fmt"
	"strings"

	"github.com/stephenwilliams/go-clitools/internal/defaults"
	"github.com/stephenwilliams/go-clitools/ptrhelpers"
	"github.com/stephenwilliams/go-clitools/tools"
	"github.com/stephenwilliams/go-clitools/tools/golang"
)

// 'Go test' automates testing the packages named by the import paths.
// It prints a summary of the test results in the format:
//
// 	ok   archive/tar   0.011s
// 	FAIL archive/zip   0.022s
// 	ok   compress/gzip 0.033s
// 	...
//
// followed by detailed output for each failed package.
//
// 'Go test' recompiles each package along with any files with names matching
// the file pattern "*_test.go".
// These additional files can contain test functions, benchmark functions, and
// example functions. See 'go help testfunc' for more.
// Each listed package causes the execution of a separate test binary.
// Files whose names begin with "_" (including "_test.go") or "." are ignored.
//
// Test files that declare a package with the suffix "_test" will be compiled as a
// separate package, and then linked and run with the main test binary.
//
// The go tool will ignore a directory named "testdata", making it available
// to hold ancillary data needed by the tests.
//
// As part of building a test binary, go test runs go vet on the package
// and its test source files to identify significant problems. If go vet
// finds any problems, go test reports those and does not run the test
// binary. Only a high-confidence subset of the default go vet checks are
// used. That subset is: 'atomic', 'bool', 'buildtags', 'errorsas',
// 'ifaceassert', 'nilfunc', 'printf', and 'stringintconv'. You can see
// the documentation for these and other vet tests via "go doc cmd/vet".
// To disable the running of go vet, use the -vet=off flag.
//
// All test output and summary lines are printed to the go command's
// standard output, even if the test printed them to its own standard
// error. (The go command's standard error is reserved for printing
// errors building the tests.)
//
// Go test runs in two different modes:
//
// The first, called local directory mode, occurs when go test is
// invoked with no package arguments (for example, 'go test' or 'go
// test -v'). In this mode, go test compiles the package sources and
// tests found in the current directory and then runs the resulting
// test binary. In this mode, caching (discussed below) is disabled.
// After the package test finishes, go test prints a summary line
// showing the test status ('ok' or 'FAIL'), package name, and elapsed
// time.
//
// The second, called package list mode, occurs when go test is invoked
// with explicit package arguments (for example 'go test math', 'go
// test ./...', and even 'go test .'). In this mode, go test compiles
// and tests each of the packages listed on the command line. If a
// package test passes, go test prints only the final 'ok' summary
// line. If a package test fails, go test prints the full test output.
// If invoked with the -bench or -v flag, go test prints the full
// output even for passing package tests, in order to display the
// requested benchmark results or verbose logging. After the package
// tests for all of the listed packages finish, and their output is
// printed, go test prints a final 'FAIL' status if any package test
// has failed.
//
// In package list mode only, go test caches successful package test
// results to avoid unnecessary repeated running of tests. When the
// result of a test can be recovered from the cache, go test will
// redisplay the previous output instead of running the test binary
// again. When this happens, go test prints '(cached)' in place of the
// elapsed time in the summary line.
//
// The rule for a match in the cache is that the run involves the same
// test binary and the flags on the command line come entirely from a
// restricted set of 'cacheable' test flags, defined as -cpu, -list,
// -parallel, -run, -short, and -v. If a run of go test has any test
// or non-test flags outside this set, the result is not cached. To
// disable test caching, use any test flag or argument other than the
// cacheable flags. The idiomatic way to disable test caching explicitly
// is to use -count=1. Tests that open files within the package's source
// root (usually $GOPATH) or that consult environment variables only
// match future runs in which the files and environment variables are unchanged.
// A cached test result is treated as executing in no time at all,
// so a successful package test result will be cached and reused
// regardless of -timeout setting.
func Test(opts ...TestOpt) *tools.CommandContext {
	options := &testOptions{}

	for _, optFunc := range opts {
		optFunc(options)
	}

	var _args []string
	_args = append(_args, "test")

	_args = append(_args, options.toArgs()...)

	return &tools.CommandContext{
		Args: _args,
		Path: tools.MustResolveTool(golang.GoToolInfo, defaults.String(options.ToolVersion, golang.DefaultToolVersion), options.ToolProvider, golang.DefaultToolProvider, tools.DefaultToolProvider),
	}
}

type TestOpt func(*testOptions)

func SetToolProvider(p tools.ToolProvider) TestOpt {
	return func(opts *testOptions) {
		opts.ToolProvider = p
	}
}

func SetToolVersion(v string) TestOpt {
	return func(opts *testOptions) {
		opts.ToolVersion = v
	}
}

// Compile the test binary to pkg.test but do not run it
// (where pkg is the last element of the package's import path).
// The file name can be changed with the -o flag.
func Compile() TestOpt {
	return func(opts *testOptions) {
		opts.compile = ptrhelpers.Bool(true)
	}
}

// By default, 'go run' runs the compiled binary directly: 'a.out arguments...'.
// If the -exec flag is given, 'go run' invokes the binary using xprog:
// 	'xprog a.out arguments...'.
// If the -exec flag is not given, GOOS or GOARCH is different from the system
// default, and a program named go_$GOOS_$GOARCH_exec can be found
// on the current search path, 'go run' invokes the binary using that program,
// for example 'go_js_wasm_exec a.out arguments...'. This allows execution of
// cross-compiled programs when a simulator or other execution method is
// available.
func Exec(value string) TestOpt {
	return func(opts *testOptions) {
		opts.exec = &value
	}
}

// Install packages that are dependencies of the test.
// Do not run the test.
func InstallDependencies() TestOpt {
	return func(opts *testOptions) {
		opts.installDependencies = ptrhelpers.Bool(true)
	}
}

// Convert test output to JSON suitable for automated processing.
// See 'go doc test2json' for the encoding details.
func JSON() TestOpt {
	return func(opts *testOptions) {
		opts.json = ptrhelpers.Bool(true)
	}
}

// Compile the test binary to the named file.
// The test still runs (unless -c or -i is specified).
func Output(value string) TestOpt {
	return func(opts *testOptions) {
		opts.output = &value
	}
}

// Pass the remainder of the command line (everything after -args)
// to the test binary, uninterpreted and unchanged.
// Because this flag consumes the remainder of the command line,
// the package list (if present) must appear before this flag.
func Args(value ...string) TestOpt {
	return func(opts *testOptions) {
		opts.args = value
	}
}

// force rebuilding of packages that are already up-to-date.
func ForceRebuild() TestOpt {
	return func(opts *testOptions) {
		opts.forceRebuild = ptrhelpers.Bool(true)
	}
}

// the number of programs, such as build commands or
// test binaries, that can be run in parallel.
// The default is the number of CPUs available.
func Workers(value int) TestOpt {
	return func(opts *testOptions) {
		opts.workers = &value
	}
}

// enable data race detection.
// Supported only on linux/amd64, freebsd/amd64, darwin/amd64, windows/amd64,
// linux/ppc64le and linux/arm64 (only for 48-bit VMA).
func Race() TestOpt {
	return func(opts *testOptions) {
		opts.race = ptrhelpers.Bool(true)
	}
}

// enable interoperation with memory sanitizer.
// Supported only on linux/amd64, linux/arm64
// and only with Clang/LLVM as the host C compiler.
// On linux/arm64, pie build mode will be used.
func EnableMemorySanitizer() TestOpt {
	return func(opts *testOptions) {
		opts.msan = ptrhelpers.Bool(true)
	}
}

// print the names of packages as they are compiled.
func Verbose() TestOpt {
	return func(opts *testOptions) {
		opts.verbose = ptrhelpers.Bool(true)
	}
}

// print the name of the temporary work directory and
// do not delete it when exiting.
func Work() TestOpt {
	return func(opts *testOptions) {
		opts.work = ptrhelpers.Bool(true)
	}
}

// value '[pattern=]arg list'
// arguments to pass on each go tool asm invocation.
func ASMFlags(value string) TestOpt {
	return func(opts *testOptions) {
		opts.asmflags = &value
	}
}

// build mode to use. See 'go help buildmode' for more.
func BuildMode(value string) TestOpt {
	return func(opts *testOptions) {
		opts.buildmode = &value
	}
}

// name of compiler to use, as in runtime.Compiler (gccgo or gc).
func Compiler(value string) TestOpt {
	return func(opts *testOptions) {
		opts.compiler = &value
	}
}

// value '[pattern=]arg list'
// arguments to pass on each gccgo compiler/linker invocation.
func GCCGoFlags(value string) TestOpt {
	return func(opts *testOptions) {
		opts.gccgoflags = &value
	}
}

// value '[pattern=]arg list'
// arguments to pass on each go tool compile invocation.
func GCCFlags(value string) TestOpt {
	return func(opts *testOptions) {
		opts.gccflags = &value
	}
}

// a suffix to use in the name of the package installation directory,
// in order to keep output separate from default builds.
// If using the -race flag, the install suffix is automatically set to race
// or, if set explicitly, has _race appended to it. Likewise for the -msan
// flag. Using a -buildmode option that requires non-default compile flags
// has a similar effect.
func InstallSuffix(value string) TestOpt {
	return func(opts *testOptions) {
		opts.installSuffix = &value
	}
}

// value '[pattern=]arg list'
// arguments to pass on each go tool link invocation.
func LDFlags(value string) TestOpt {
	return func(opts *testOptions) {
		opts.ldflags = &value
	}
}

// build code that will be linked against shared libraries previously
// created with -buildmode=shared.
func LinkShared() TestOpt {
	return func(opts *testOptions) {
		opts.linkShared = ptrhelpers.Bool(true)
	}
}

// module download mode to use: readonly, vendor, or mod.
// See 'go help modules' for more.
func Mod(value string) TestOpt {
	return func(opts *testOptions) {
		opts.mod = &value
	}
}

// leave newly-created directories in the module cache read-write
// instead of making them read-only.
func ModCacheRW() TestOpt {
	return func(opts *testOptions) {
		opts.modcacherw = ptrhelpers.Bool(true)
	}
}

// in module aware mode, read (and possibly write) an alternate go.mod
// file instead of the one in the module root directory. A file named
// "go.mod" must still be present in order to determine the module root
// directory, but it is not accessed. When -modfile is specified, an
// alternate go.sum file is also used: its path is derived from the
// -modfile flag by trimming the ".mod" extension and appending ".sum".
func ModFile(value string) TestOpt {
	return func(opts *testOptions) {
		opts.modfile = &value
	}
}

// install and load all packages from dir instead of the usual locations.
// For example, when building with a non-standard configuration,
// use -pkgdir to keep generated packages in a separate location
func PackageDir(value string) TestOpt {
	return func(opts *testOptions) {
		opts.pkgdir = &value
	}
}

// a comma-separated list of build tags to consider satisfied during the
// build. For more information about build tags, see the description of
// build constraints in the documentation for the go/build package.
// (Earlier versions of Go used a space-separated list, and that form
// is deprecated but still recognized.)
// NOTE: comma separation is handled automatically
func Tags(value ...string) TestOpt {
	return func(opts *testOptions) {
		opts.tags = value
	}
}

// remove all file system paths from the resulting executable.
// Instead of absolute file system paths, the recorded file names
// will begin with either "go" (for the standard library),
// or a module path@version (when using modules),
// or a plain import path (when using GOPATH).
func TrimPath() TestOpt {
	return func(opts *testOptions) {
		opts.trimpath = ptrhelpers.Bool(true)
	}
}

// a program to use to invoke toolchain programs like vet and asm.
// For example, instead of running asm, the go command will run
// 'cmd args /path/to/asm <arguments for asm>'.
func ToolExec(value string) TestOpt {
	return func(opts *testOptions) {
		opts.toolexec = &value
	}
}

// print the commands but do not run them.
func PrintCommandsOnly() TestOpt {
	return func(opts *testOptions) {
		opts.printCommandsOnly = ptrhelpers.Bool(true)
	}
}

// print the commands.
func PrintCommands() TestOpt {
	return func(opts *testOptions) {
		opts.printCommands = ptrhelpers.Bool(true)
	}
}

type testOptions struct {
	ToolProvider        tools.ToolProvider
	ToolVersion         string
	compile             *bool
	exec                *string
	installDependencies *bool
	json                *bool
	output              *string
	args                []string
	forceRebuild        *bool
	workers             *int
	race                *bool
	msan                *bool
	verbose             *bool
	work                *bool
	asmflags            *string
	buildmode           *string
	compiler            *string
	gccgoflags          *string
	gccflags            *string
	installSuffix       *string
	ldflags             *string
	linkShared          *bool
	mod                 *string
	modcacherw          *bool
	modfile             *string
	pkgdir              *string
	tags                []string
	trimpath            *bool
	toolexec            *string
	printCommandsOnly   *bool
	printCommands       *bool
}

func (o *testOptions) toArgs() []string {
	var renderedArgs []string

	if o.compile != nil {
		renderedArgs = append(renderedArgs, "-c")
	}

	if o.exec != nil {
		renderedArgs = append(renderedArgs, "-exec", fmt.Sprintf("%s", ptrhelpers.StringValue(o.exec)))
	}

	if o.installDependencies != nil {
		renderedArgs = append(renderedArgs, "-i")
	}

	if o.json != nil {
		renderedArgs = append(renderedArgs, "-json")
	}

	if o.output != nil {
		renderedArgs = append(renderedArgs, "-o", fmt.Sprintf("%s", ptrhelpers.StringValue(o.output)))
	}

	if o.args != nil {
		renderedArgs = append(renderedArgs, "-args")
	}

	if o.forceRebuild != nil {
		renderedArgs = append(renderedArgs, "-a")
	}

	if o.workers != nil {
		renderedArgs = append(renderedArgs, "-p", fmt.Sprintf("%d", ptrhelpers.IntValue(o.workers)))
	}

	if o.race != nil {
		renderedArgs = append(renderedArgs, "-race")
	}

	if o.msan != nil {
		renderedArgs = append(renderedArgs, "-msan")
	}

	if o.verbose != nil {
		renderedArgs = append(renderedArgs, "-v")
	}

	if o.work != nil {
		renderedArgs = append(renderedArgs, "-work")
	}

	if o.asmflags != nil {
		renderedArgs = append(renderedArgs, "-asmflags", fmt.Sprintf("%s", ptrhelpers.StringValue(o.asmflags)))
	}

	if o.buildmode != nil {
		renderedArgs = append(renderedArgs, "-buildmode", fmt.Sprintf("%s", ptrhelpers.StringValue(o.buildmode)))
	}

	if o.compiler != nil {
		renderedArgs = append(renderedArgs, "-compiler", fmt.Sprintf("%s", ptrhelpers.StringValue(o.compiler)))
	}

	if o.gccgoflags != nil {
		renderedArgs = append(renderedArgs, "-gccgoflags", fmt.Sprintf("%s", ptrhelpers.StringValue(o.gccgoflags)))
	}

	if o.gccflags != nil {
		renderedArgs = append(renderedArgs, "-gccflags", fmt.Sprintf("%s", ptrhelpers.StringValue(o.gccflags)))
	}

	if o.installSuffix != nil {
		renderedArgs = append(renderedArgs, "-installsuffix", fmt.Sprintf("%s", ptrhelpers.StringValue(o.installSuffix)))
	}

	if o.ldflags != nil {
		renderedArgs = append(renderedArgs, "-ldflags", fmt.Sprintf("%s", ptrhelpers.StringValue(o.ldflags)))
	}

	if o.linkShared != nil {
		renderedArgs = append(renderedArgs, "-linkshared")
	}

	if o.mod != nil {
		renderedArgs = append(renderedArgs, "-mod", fmt.Sprintf("%s", ptrhelpers.StringValue(o.mod)))
	}

	if o.modcacherw != nil {
		renderedArgs = append(renderedArgs, "-modcacherw")
	}

	if o.modfile != nil {
		renderedArgs = append(renderedArgs, "-modfile", fmt.Sprintf("%s", ptrhelpers.StringValue(o.modfile)))
	}

	if o.pkgdir != nil {
		renderedArgs = append(renderedArgs, "-pkgdir", fmt.Sprintf("%s", ptrhelpers.StringValue(o.pkgdir)))
	}

	if o.tags != nil {
		renderedArgs = append(renderedArgs, "-tags", fmt.Sprintf("%s", strings.Join(o.tags, ",")))
	}

	if o.trimpath != nil {
		renderedArgs = append(renderedArgs, "-trimpath")
	}

	if o.toolexec != nil {
		renderedArgs = append(renderedArgs, "-toolexec", fmt.Sprintf("%s", ptrhelpers.StringValue(o.toolexec)))
	}

	if o.printCommandsOnly != nil {
		renderedArgs = append(renderedArgs, "-n")
	}

	if o.printCommands != nil {
		renderedArgs = append(renderedArgs, "-x")
	}

	return renderedArgs
}
