// Generated by toolgen. DO NOT EDIT.
// Generated from tool specification:
//   _build/specifications/go.json

package list

import (
	"fmt"

	"github.com/stephenwilliams/go-clitools/internal/defaults"
	"github.com/stephenwilliams/go-clitools/ptrhelpers"
	"github.com/stephenwilliams/go-clitools/tools"
	"github.com/stephenwilliams/go-clitools/tools/golang"
)

// List lists the named packages, one per line.
// The most commonly-used flags are -f and -json, which control the form
// of the output printed for each package. Other list flags, documented below,
// control more specific details.
//
// The default output shows the package import path:
//
//     bytes
//     encoding/json
//     github.com/gorilla/mux
//     golang.org/x/net/html
func List(opts ...ListOpt) *tools.CommandContext {
	options := &listOptions{}

	for _, optFunc := range opts {
		optFunc(options)
	}

	var _args []string
	_args = append(_args, "list")

	_args = append(_args, options.toArgs()...)

	return &tools.CommandContext{
		Args: _args,
		Path: tools.MustResolveTool(golang.GoToolInfo, defaults.String(options.ToolVersion, golang.DefaultToolVersion), options.ToolProvider, golang.DefaultToolProvider, tools.DefaultToolProvider),
	}
}

// List lists the named packages, one per line.
// The most commonly-used flags are -f and -json, which control the form
// of the output printed for each package. Other list flags, documented below,
// control more specific details.
//
// The default output shows the package import path:
//
//     bytes
//     encoding/json
//     github.com/gorilla/mux
//     golang.org/x/net/html
func ListWithPackage(pkg string, opts ...ListOpt) *tools.CommandContext {
	options := &listOptions{}

	for _, optFunc := range opts {
		optFunc(options)
	}

	var _args []string
	_args = append(_args, "list")

	_args = append(_args, options.toArgs()...)
	_args = append(_args, pkg)

	return &tools.CommandContext{
		Args: _args,
		Path: tools.MustResolveTool(golang.GoToolInfo, defaults.String(options.ToolVersion, golang.DefaultToolVersion), options.ToolProvider, golang.DefaultToolProvider, tools.DefaultToolProvider),
	}
}

// List lists the named packages, one per line.
// The most commonly-used flags are -f and -json, which control the form
// of the output printed for each package. Other list flags, documented below,
// control more specific details.
//
// The default output shows the package import path:
//
//     bytes
//     encoding/json
//     github.com/gorilla/mux
//     golang.org/x/net/html
func ListWithPackages(pkgs []string, opts ...ListOpt) *tools.CommandContext {
	options := &listOptions{}

	for _, optFunc := range opts {
		optFunc(options)
	}

	var _args []string
	_args = append(_args, "list")

	_args = append(_args, options.toArgs()...)
	_args = append(_args, pkgs...)

	return &tools.CommandContext{
		Args: _args,
		Path: tools.MustResolveTool(golang.GoToolInfo, defaults.String(options.ToolVersion, golang.DefaultToolVersion), options.ToolProvider, golang.DefaultToolProvider, tools.DefaultToolProvider),
	}
}

type ListOpt func(*listOptions)

func SetToolProvider(p tools.ToolProvider) ListOpt {
	return func(opts *listOptions) {
		opts.ToolProvider = p
	}
}

func SetToolVersion(v string) ListOpt {
	return func(opts *listOptions) {
		opts.ToolVersion = v
	}
}

// The -f flag specifies an alternate format for the list, using the
// syntax of package template. The default output is equivalent
// to -f '{{.ImportPath}}'. The struct being passed to the template is:
//
//     type Package struct {
//         Dir           string   // directory containing package sources
//         ImportPath    string   // import path of package in dir
//         ImportComment string   // path in import comment on package statement
//         Name          string   // package name
//         Doc           string   // package documentation string
//         Target        string   // install path
//         Shlib         string   // the shared library that contains this package (only set when -linkshared)
//         Goroot        bool     // is this package in the Go root?
//         Standard      bool     // is this package part of the standard Go library?
//         Stale         bool     // would 'go install' do anything for this package?
//         StaleReason   string   // explanation for Stale==true
//         Root          string   // Go root or Go path dir containing this package
//         ConflictDir   string   // this directory shadows Dir in $GOPATH
//         BinaryOnly    bool     // binary-only package (no longer supported)
//         ForTest       string   // package is only for use in named test
//         Export        string   // file containing export data (when using -export)
//         Module        *Module  // info about package's containing module, if any (can be nil)
//         Match         []string // command-line patterns matching this package
//         DepOnly       bool     // package is only a dependency, not explicitly listed
//
//         // Source files
//         GoFiles         []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)
//         CgoFiles        []string // .go source files that import "C"
//         CompiledGoFiles []string // .go files presented to compiler (when using -compiled)
//         IgnoredGoFiles  []string // .go source files ignored due to build constraints
//         CFiles          []string // .c source files
//         CXXFiles        []string // .cc, .cxx and .cpp source files
//         MFiles          []string // .m source files
//         HFiles          []string // .h, .hh, .hpp and .hxx source files
//         FFiles          []string // .f, .F, .for and .f90 Fortran source files
//         SFiles          []string // .s source files
//         SwigFiles       []string // .swig files
//         SwigCXXFiles    []string // .swigcxx files
//         SysoFiles       []string // .syso object files to add to archive
//         TestGoFiles     []string // _test.go files in package
//         XTestGoFiles    []string // _test.go files outside package
//
//         // Cgo directives
//         CgoCFLAGS    []string // cgo: flags for C compiler
//         CgoCPPFLAGS  []string // cgo: flags for C preprocessor
//         CgoCXXFLAGS  []string // cgo: flags for C++ compiler
//         CgoFFLAGS    []string // cgo: flags for Fortran compiler
//         CgoLDFLAGS   []string // cgo: flags for linker
//         CgoPkgConfig []string // cgo: pkg-config names
//
//         // Dependency information
//         Imports      []string          // import paths used by this package
//         ImportMap    map[string]string // map from source import to ImportPath (identity entries omitted)
//         Deps         []string          // all (recursively) imported dependencies
//         TestImports  []string          // imports from TestGoFiles
//         XTestImports []string          // imports from XTestGoFiles
//
//         // Error information
//         Incomplete bool            // this package or a dependency has an error
//         Error      *PackageError   // error loading package
//         DepsErrors []*PackageError // errors loading dependencies
//     }
//
// Packages stored in vendor directories report an ImportPath that includes the
// path to the vendor directory (for example, "d/vendor/p" instead of "p"),
// so that the ImportPath uniquely identifies a given copy of a package.
// The Imports, Deps, TestImports, and XTestImports lists also contain these
// expanded import paths. See golang.org/s/go15vendor for more about vendoring.
//
// The error information, if any, is
//
//     type PackageError struct {
//         ImportStack   []string // shortest path from package named on command line to this one
//         Pos           string   // position of error (if present, file:line:col)
//         Err           string   // the error itself
//     }
//
// The module information is a Module struct, defined in the discussion
// of list -m below.
//
// The template function "join" calls strings.Join.
//
// The template function "context" returns the build context, defined as:
//
//     type Context struct {
//         GOARCH        string   // target architecture
//         GOOS          string   // target operating system
//         GOROOT        string   // Go root
//         GOPATH        string   // Go path
//         CgoEnabled    bool     // whether cgo can be used
//         UseAllFiles   bool     // use files regardless of +build lines, file names
//         Compiler      string   // compiler to assume when computing target paths
//         BuildTags     []string // build constraints to match in +build lines
//         ReleaseTags   []string // releases the current release is compatible with
//         InstallSuffix string   // suffix to use in the name of the install dir
//     }
//
// For more information about the meaning of these fields see the documentation
// for the go/build package's Context type.
func Format(value string) ListOpt {
	return func(opts *listOptions) {
		opts.format = &value
	}
}

// causes the package data to be printed in JSON format
// instead of using the template format.
func JSON() ListOpt {
	return func(opts *listOptions) {
		opts.json = ptrhelpers.Bool(true)
	}
}

// causes list to set CompiledGoFiles to the Go source
// files presented to the compiler. Typically this means that it repeats
// the files listed in GoFiles and then also adds the Go code generated
// by processing CgoFiles and SwigFiles. The Imports list contains the
// union of all imports from both GoFiles and CompiledGoFiles.
func Compiled() ListOpt {
	return func(opts *listOptions) {
		opts.compiled = ptrhelpers.Bool(true)
	}
}

// causes list to iterate over not just the named packages
// but also all their dependencies. It visits them in a depth-first post-order
// traversal, so that a package is listed only after all its dependencies.
// Packages not explicitly listed on the command line will have the DepOnly
// field set to true.
func Dependencies() ListOpt {
	return func(opts *listOptions) {
		opts.dep = ptrhelpers.Bool(true)
	}
}

// changes the handling of erroneous packages, those that
// cannot be found or are malformed. By default, the list command
// prints an error to standard error for each erroneous package and
// omits the packages from consideration during the usual printing.
// With the -e flag, the list command never prints errors to standard
// error and instead processes the erroneous packages with the usual
// printing. Erroneous packages will have a non-empty ImportPath and
// a non-nil Error field; other information may or may not be missing
// (zeroed).
func ErrorHandling() ListOpt {
	return func(opts *listOptions) {
		opts.errorHandling = ptrhelpers.Bool(true)
	}
}

// causes list to set the Export field to the name of a
// file containing up-to-date export information for the given package.
func Export() ListOpt {
	return func(opts *listOptions) {
		opts.export = ptrhelpers.Bool(true)
	}
}

// causes list to identify the named packages but not
// resolve their dependencies: the Imports and Deps lists will be empty.
func Find() ListOpt {
	return func(opts *listOptions) {
		opts.find = ptrhelpers.Bool(true)
	}
}

// causes list to report not only the named packages
// but also their test binaries (for packages with tests), to convey to
// source code analysis tools exactly how test binaries are constructed.
// The reported import path for a test binary is the import path of
// the package followed by a ".test" suffix, as in "math/rand.test".
// When building a test, it is sometimes necessary to rebuild certain
// dependencies specially for that test (most commonly the tested
// package itself). The reported import path of a package recompiled
// for a particular test binary is followed by a space and the name of
// the test binary in brackets, as in "math/rand [math/rand.test]"
// or "regexp [sort.test]". The ForTest field is also set to the name
// of the package being tested ("math/rand" or "sort" in the previous
// examples).
//
// The Dir, Target, Shlib, Root, ConflictDir, and Export file paths
// are all absolute paths.
//
// By default, the lists GoFiles, CgoFiles, and so on hold names of files in Dir
// (that is, paths relative to Dir, not absolute paths).
// The generated files added when using the -compiled and -test flags
// are absolute paths referring to cached copies of generated Go source files.
// Although they are Go source files, the paths may not end in ".go".
func Test() ListOpt {
	return func(opts *listOptions) {
		opts.test = ptrhelpers.Bool(true)
	}
}

// causes list to list modules instead of packages.
//
// When listing modules, the -f flag still specifies a format template
// applied to a Go struct, but now a Module struct:
//
//     type Module struct {
//         Path      string       // module path
//         Version   string       // module version
//         Versions  []string     // available module versions (with -versions)
//         Replace   *Module      // replaced by this module
//         Time      *time.Time   // time version was created
//         Update    *Module      // available update, if any (with -u)
//         Main      bool         // is this the main module?
//         Indirect  bool         // is this module only an indirect dependency of main module?
//         Dir       string       // directory holding files for this module, if any
//         GoMod     string       // path to go.mod file used when loading this module, if any
//         GoVersion string       // go version used in module
//         Error     *ModuleError // error loading module
//     }
//
//     type ModuleError struct {
//         Err string // the error itself
//     }
//
// The file GoMod refers to may be outside the module directory if the
// module is in the module cache or if the -modfile flag is used.
//
// The default output is to print the module path and then
// information about the version and replacement if any.
// For example, 'go list -m all' might print:
//
//     my/main/module
//     golang.org/x/text v0.3.0 => /tmp/text
//     rsc.io/pdf v0.1.1
//
// The Module struct has a String method that formats this
// line of output, so that the default format is equivalent
// to -f '{{.String}}'.
//
// Note that when a module has been replaced, its Replace field
// describes the replacement module, and its Dir field is set to
// the replacement's source code, if present. (That is, if Replace
// is non-nil, then Dir is set to Replace.Dir, with no access to
// the replaced source code.)
//
// The -u flag adds information about available upgrades.
// When the latest version of a given module is newer than
// the current one, list -u sets the Module's Update field
// to information about the newer module.
// The Module's String method indicates an available upgrade by
// formatting the newer version in brackets after the current version.
// For example, 'go list -m -u all' might print:
//
//     my/main/module
//     golang.org/x/text v0.3.0 [v0.4.0] => /tmp/text
//     rsc.io/pdf v0.1.1 [v0.1.2]
//
// (For tools, 'go list -m -u -json all' may be more convenient to parse.)
func Module() ListOpt {
	return func(opts *listOptions) {
		opts.module = ptrhelpers.Bool(true)
	}
}

// causes list to set the Module's Versions field
// to a list of all known versions of that module, ordered according
// to semantic versioning, earliest to latest. The flag also changes
// the default output format to display the module path followed by the
// space-separated version list.
func Versions() ListOpt {
	return func(opts *listOptions) {
		opts.versions = ptrhelpers.Bool(true)
	}
}

type listOptions struct {
	ToolProvider  tools.ToolProvider
	ToolVersion   string
	format        *string
	json          *bool
	compiled      *bool
	dep           *bool
	errorHandling *bool
	export        *bool
	find          *bool
	test          *bool
	module        *bool
	versions      *bool
}

func (o *listOptions) toArgs() []string {
	var renderedArgs []string

	if o.format != nil {
		renderedArgs = append(renderedArgs, "-f", fmt.Sprintf("%s", ptrhelpers.StringValue(o.format)))
	}

	if o.json != nil {
		renderedArgs = append(renderedArgs, "-json")
	}

	if o.compiled != nil {
		renderedArgs = append(renderedArgs, "-compiled")
	}

	if o.dep != nil {
		renderedArgs = append(renderedArgs, "-dep")
	}

	if o.errorHandling != nil {
		renderedArgs = append(renderedArgs, "-e")
	}

	if o.export != nil {
		renderedArgs = append(renderedArgs, "-export")
	}

	if o.find != nil {
		renderedArgs = append(renderedArgs, "-find")
	}

	if o.test != nil {
		renderedArgs = append(renderedArgs, "-test")
	}

	if o.module != nil {
		renderedArgs = append(renderedArgs, "-m")
	}

	if o.versions != nil {
		renderedArgs = append(renderedArgs, "-versions")
	}

	return renderedArgs
}
