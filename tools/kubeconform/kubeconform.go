// Generated by toolgen. DO NOT EDIT.
// Generated from tool specification:
//   _build/specifications/kubeconform.json

package kubeconform

import (
	"fmt"

	"github.com/stephenwilliams/go-clitools/internal/defaults"
	"github.com/stephenwilliams/go-clitools/ptrhelpers"
	"github.com/stephenwilliams/go-clitools/tools"
)

func KubeConform(fileOrFolder string, opts ...KubeConformOpt) *tools.CommandContext {
	options := &kubeconformOptions{}

	for _, optFunc := range opts {
		optFunc(options)
	}

	var _args []string

	_args = append(_args, options.toArgs()...)
	if fileOrFolder != "" {
		_args = append(_args, fileOrFolder)
	}

	return &tools.CommandContext{
		Args: _args,
		Path: tools.MustResolveTool(KubeConformToolInfo, defaults.String(options.ToolVersion, DefaultToolVersion), options.ToolProvider, DefaultToolProvider, tools.DefaultToolProvider),
	}
}

func KubeConformWithFilesOrFolders(filesOrFolders []string, opts ...KubeConformOpt) *tools.CommandContext {
	options := &kubeconformOptions{}

	for _, optFunc := range opts {
		optFunc(options)
	}

	var _args []string

	_args = append(_args, options.toArgs()...)
	_args = append(_args, filesOrFolders...)

	return &tools.CommandContext{
		Args: _args,
		Path: tools.MustResolveTool(KubeConformToolInfo, defaults.String(options.ToolVersion, DefaultToolVersion), options.ToolProvider, DefaultToolProvider, tools.DefaultToolProvider),
	}
}

type KubeConformOpt func(*kubeconformOptions)

func SetToolProvider(p tools.ToolProvider) KubeConformOpt {
	return func(opts *kubeconformOptions) {
		opts.ToolProvider = p
	}
}

func SetToolVersion(v string) KubeConformOpt {
	return func(opts *kubeconformOptions) {
		opts.ToolVersion = v
	}
}

// cache schemas downloaded via HTTP to this folder
func Cache(value string) KubeConformOpt {
	return func(opts *kubeconformOptions) {
		opts.cache = &value
	}
}

// debug - log CPU profiling to file
func CPUProf(value string) KubeConformOpt {
	return func(opts *kubeconformOptions) {
		opts.cpuProf = &value
	}
}

// regular expression specifying paths to ignore
func IgnoreFilenamePattern(value ...string) KubeConformOpt {
	return func(opts *kubeconformOptions) {
		opts.ignoreFilenamePattern = append(opts.ignoreFilenamePattern, value...)
	}
}

// skip files with missing schemas instead of failing
func IgnoreMissingSchemas() KubeConformOpt {
	return func(opts *kubeconformOptions) {
		opts.ignoreMissingSchemas = ptrhelpers.Bool(true)
	}
}

// version of Kubernetes to validate against, e.g.: 1.18.0 (default "master")
func KubernetesVersion(value string) KubeConformOpt {
	return func(opts *kubeconformOptions) {
		opts.kubernetesVersion = &value
	}
}

// number of goroutines to run concurrently (default 4)
func N(value int) KubeConformOpt {
	return func(opts *kubeconformOptions) {
		opts.n = &value
	}
}

// output format - json, junit, tap, text (default "text")
func Output(value string) KubeConformOpt {
	return func(opts *kubeconformOptions) {
		opts.output = &value
	}
}

// comma-separated list of kinds to reject
func Reject(value string) KubeConformOpt {
	return func(opts *kubeconformOptions) {
		opts.reject = &value
	}
}

// override schemas location search path
func SchemaLocation(value ...string) KubeConformOpt {
	return func(opts *kubeconformOptions) {
		opts.schemaLocation = append(opts.schemaLocation, value...)
	}
}

// comma-separated list of kinds to ignore
func Skip(value string) KubeConformOpt {
	return func(opts *kubeconformOptions) {
		opts.skip = &value
	}
}

// disallow additional properties not in schema
func Strict() KubeConformOpt {
	return func(opts *kubeconformOptions) {
		opts.strict = ptrhelpers.Bool(true)
	}
}

// print a summary at the end (ignored for junit output)
func Summary() KubeConformOpt {
	return func(opts *kubeconformOptions) {
		opts.summary = ptrhelpers.Bool(true)
	}
}

// print results for all resources (ignored for tap and junit output)
func Verbose() KubeConformOpt {
	return func(opts *kubeconformOptions) {
		opts.verbose = ptrhelpers.Bool(true)
	}
}

type kubeconformOptions struct {
	ToolProvider          tools.ToolProvider
	ToolVersion           string
	cache                 *string
	cpuProf               *string
	ignoreFilenamePattern []string
	ignoreMissingSchemas  *bool
	kubernetesVersion     *string
	n                     *int
	output                *string
	reject                *string
	schemaLocation        []string
	skip                  *string
	strict                *bool
	summary               *bool
	verbose               *bool
}

func (o *kubeconformOptions) toArgs() []string {
	var renderedArgs []string

	if o.cache != nil {
		renderedArgs = append(renderedArgs, "-cache", fmt.Sprintf("%s", ptrhelpers.StringValue(o.cache)))
	}

	if o.cpuProf != nil {
		renderedArgs = append(renderedArgs, "-cpu-prof", fmt.Sprintf("%s", ptrhelpers.StringValue(o.cpuProf)))
	}

	if o.ignoreFilenamePattern != nil {
		for _, v := range o.ignoreFilenamePattern {
			renderedArgs = append(renderedArgs, "-ignore-filename-pattern", fmt.Sprintf("%s", v))
		}
	}

	if o.ignoreMissingSchemas != nil {
		renderedArgs = append(renderedArgs, "-ignore-missing-schemas")
	}

	if o.kubernetesVersion != nil {
		renderedArgs = append(renderedArgs, "-kubernetes-version", fmt.Sprintf("%s", ptrhelpers.StringValue(o.kubernetesVersion)))
	}

	if o.n != nil {
		renderedArgs = append(renderedArgs, "-n", fmt.Sprintf("%d", ptrhelpers.IntValue(o.n)))
	}

	if o.output != nil {
		renderedArgs = append(renderedArgs, "-output", fmt.Sprintf("%s", ptrhelpers.StringValue(o.output)))
	}

	if o.reject != nil {
		renderedArgs = append(renderedArgs, "-reject", fmt.Sprintf("%s", ptrhelpers.StringValue(o.reject)))
	}

	if o.schemaLocation != nil {
		for _, v := range o.schemaLocation {
			renderedArgs = append(renderedArgs, "-schema-location", fmt.Sprintf("%s", v))
		}
	}

	if o.skip != nil {
		renderedArgs = append(renderedArgs, "-skip", fmt.Sprintf("%s", ptrhelpers.StringValue(o.skip)))
	}

	if o.strict != nil {
		renderedArgs = append(renderedArgs, "-strict")
	}

	if o.summary != nil {
		renderedArgs = append(renderedArgs, "-summary")
	}

	if o.verbose != nil {
		renderedArgs = append(renderedArgs, "-verbose")
	}

	return renderedArgs
}
